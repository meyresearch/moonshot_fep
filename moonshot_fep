{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4d0468a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "import BioSimSpace as BSS\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os\n",
    "import matplotlib as mpl\n",
    "import matplotlib.pyplot as plt\n",
    "import time"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c27b3eb9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Plot and save heatmaps of overlap matrixes\n",
    "\n",
    "def getHeatMap(bound, free, title):\n",
    "    fig, axs = plt.subplots(ncols = 2, nrows = 1, figsize = (20, 10), constrained_layout = True)\n",
    "    fig.supxlabel('λ index',fontsize = 14)\n",
    "    fig.supylabel('λ index',fontsize = 14)\n",
    "    \n",
    "    cmap = mpl.cm.viridis\n",
    "    bounds = [0, 0.1, 0.2, 0.4, 0.6, 0.8]\n",
    "    norm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n",
    "    fig.colorbar(mpl.cm.ScalarMappable(norm = norm, cmap = cmap))\n",
    "    \n",
    "    for col in range(2):\n",
    "        if col == 0:\n",
    "            leg = \"Bound leg\"\n",
    "            matrix = np.array(bound)\n",
    "        else:\n",
    "            leg = \"Free leg\"\n",
    "            matrix = np.array(free)\n",
    "        lamb = matrix.shape[0]\n",
    "\n",
    "        im = axs[col].imshow(matrix, norm = norm, cmap = cmap)   \n",
    "        \n",
    "        axs[col].set_xticks(np.arange(lamb), labels = np.arange(lamb))\n",
    "        axs[col].set_yticks(np.arange(lamb), labels = np.arange(lamb))\n",
    "        \n",
    "        axs[col].set_title(leg, fontsize=16)\n",
    "        axs[col].spines[:].set_visible(False)\n",
    "        axs[col].grid(visible = True, which = \"minor\", axis = 'both', color = \"w\", linestyle = '-', linewidth = 3)\n",
    "        \n",
    "        for i in range(lamb):\n",
    "            for j in range(lamb):\n",
    "                text = axs[col].text(j, i, '{:.2f}'.format(matrix[i, j]), ha = \"center\", va = \"center\", color = \"w\", fontsize = 12)\n",
    "    \n",
    "    fig.savefig(fname = './output/' + title)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3fa6ef4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def getPertSys(testset, ref_ligand, protein):\n",
    "    for index, row in testset.iterrows():\n",
    "        title = row['Molecule Name']\n",
    "        path = os.path.join('pertSystems', title)\n",
    "        \n",
    "        if os.path.exists(path):\n",
    "            print(\"Perturtable system for \" + title + \" exists\")\n",
    "        else:\n",
    "            # Parametrise the ligand \n",
    "            print(\"Parameterising \" + title +  \" ...\")\n",
    "            ligand = BSS.IO.readMolecules(os.path.join('input','ligands',title) + '.pdb')[0]    \n",
    "            ligand = BSS.Parameters.gaff2(ligand, work_dir = './lig_par/' + title).getMolecule()\n",
    "\n",
    "            # Morph and combine systems\n",
    "            mapping = BSS.Align.matchAtoms(ligand, ref_ligand)\n",
    "            ligand = BSS.Align.rmsdAlign(ligand, ref_ligand, mapping)\n",
    "            merged = BSS.Align.merge(ligand, ref_ligand, mapping)\n",
    "            complx = merged + protein \n",
    "\n",
    "            print(\"Solvating \" + title + \" ...\")\n",
    "            # Solvate the protein ligand complex and merged ligand in water\n",
    "            complx_sol = BSS.Solvent.tip3p(molecule = complx, box = 3*[90*BSS.Units.Length.angstrom])\n",
    "            merged_sol = BSS.Solvent.tip3p(molecule = merged, box = 3*[35*BSS.Units.Length.angstrom])\n",
    "            \n",
    "            print(\"Minimising \" + title + \" ...\")\n",
    "            minimisation_complex_path = os.path.join('minimisation',title,'complex')\n",
    "            minimisation_merged_path = os.path.join('minimisation',title,'merged')\n",
    "            # Create the minimisation protocol\n",
    "            prot_minimisation = BSS.Protocol.Minimisation(steps = 3000)  \n",
    "            # Minimise both legs\n",
    "            proc_minimisation_complx = BSS.MD.run(complx_sol, \n",
    "                                                  prot_minimisation, \n",
    "                                                  work_dir = minimisation_complex_path,\n",
    "                                                  gpu_support = True)\n",
    "            while proc_minimisation_complx.isRunning():\n",
    "                print('proc_minimisation_complx',proc_minimisation_complx.runTime())\n",
    "                time.sleep(120)\n",
    "            complx_minimised = proc_minimisation_complx.getSystem(block = True) \n",
    "            proc_minimisation_merged = BSS.MD.run(merged_sol, \n",
    "                                                  prot_minimisation, \n",
    "                                                  work_dir = minimisation_merged_path,\n",
    "                                                  gpu_support = True)\n",
    "            while proc_minimisation_merged.isRunning():\n",
    "                print('proc_minimisation_merged', proc_minimisation_merged.runTime())\n",
    "                time.sleep(120)\n",
    "            merged_minimised = proc_minimisation_merged.getSystem(block = True)\n",
    "                \n",
    "            print(\"Equilibrating \" + title + \" ...\")\n",
    "            equilibration_complex_path = os.path.join('equilibration',title,'complex')\n",
    "            equilibration_merged_path = os.path.join('equilibration',title,'merged')            \n",
    "            # Create the equilibration protocol\n",
    "            prot_equilibration = BSS.Protocol.Equilibration(timestep = 2*BSS.Units.Time.femtosecond,\n",
    "                                                            runtime = 200*BSS.Units.Time.picosecond)            \n",
    "            # Equilibrate both legs\n",
    "            proc_equilibration_complx = BSS.MD.run(complx_minimised,\n",
    "                                                   prot_equilibration,\n",
    "                                                   work_dir = equilibration_complex_path,\n",
    "                                                   gpu_support = True)\n",
    "            while proc_equilibration_complx.isRunning():\n",
    "                print('proc_equilibration_complx', proc_equilibration_complx.runTime())\n",
    "                time.sleep(300)\n",
    "            complx_equilibrated = proc_equilibration_complx.getSystem(block = True)\n",
    "            BSS.IO.savePerturbableSystem(path + '/' + title + '_bound', complx_equilibrated)\n",
    "            print(\"Perturbable systems for \" + title + \" complex saved\")\n",
    "            \n",
    "            proc_equilibration_merged = BSS.MD.run(merged_minimised, \n",
    "                                                    prot_equilibration,\n",
    "                                                    work_dir = equilibration_merged_path,\n",
    "                                                    gpu_support = True)\n",
    "            while proc_equilibration_merged.isRunning():\n",
    "                print('proc_equilibration_merged', proc_equilibration_merged.runTime())\n",
    "                time.sleep(300)\n",
    "            merged_equilibrated = proc_equilibration_merged.getSystem(block = True)\n",
    "            BSS.IO.savePerturbableSystem(path + '/' + title + '_free', merged_equilibrated)\n",
    "            \n",
    "            print(\"Perturbable systems for \" + title + \" merged saved\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "014fdd0f",
   "metadata": {},
   "outputs": [],
   "source": [
    "def getFreeEnergy(title, lam_bound, lam_free):\n",
    "    # Read perturbable system\n",
    "    path = \"./pertSystems/\" + title + '/'\n",
    "    boundSystem = BSS.IO.readPerturbableSystem(path + title + '_bound0.prm7', path + title + '_bound0.rst7',\n",
    "                                                path + title + '_bound1.prm7', path + title + '_bound1.rst7')\n",
    "    freeSystem = BSS.IO.readPerturbableSystem(path + title + '_free0.prm7', path + title + '_free0.rst7',\n",
    "                                                path + title + '_free1.prm7', path + title + '_free1.rst7')\n",
    "    \n",
    "    # Create the free energy protocols\n",
    "    prot_bound = BSS.Protocol.FreeEnergy(timestep = 2*BSS.Units.Time.femtosecond,\n",
    "                                         runtime = 200*BSS.Units.Time.picosecond,\n",
    "                                         num_lam = lam_bound)\n",
    "    prot_free = BSS.Protocol.FreeEnergy(timestep = 2*BSS.Units.Time.femtosecond,\n",
    "                                        runtime = 200*BSS.Units.Time.picosecond,\n",
    "                                        num_lam = lam_free)\n",
    "    \n",
    "    # Initialise the free energy object for each leg\n",
    "    fep_bound = BSS.FreeEnergy.Relative(boundSystem,\n",
    "                                        prot_bound,\n",
    "                                        engine = \"somd\",\n",
    "                                        work_dir = './somd/' + title + \"/bound\")\n",
    "    fep_free = BSS.FreeEnergy.Relative(freeSystem,\n",
    "                                       prot_free,\n",
    "                                       engine = \"somd\",\n",
    "                                       work_dir = './somd/' + title + \"/free\")\n",
    "    \n",
    "    # Run FEP\n",
    "    print(\"Computing FEP for \" + title + \" bound leg ...\")\n",
    "    fep_bound.run()\n",
    "    fep_bound.wait()\n",
    "    print(\"Computing FEP for \" + title + \" free leg ...\")\n",
    "    fep_free.run()\n",
    "    fep_free.wait()\n",
    "    \n",
    "    # Get the PMF and the overlap matrix\n",
    "    pmf_bound, overlap_bound = fep_bound.analyse()\n",
    "    pmf_free, overlap_free = fep_free.analyse()\n",
    "    \n",
    "    # Compute the relative free-energy difference with PMF\n",
    "    # dG_bound-dG_free = dG_ref,bind - dG_lig,bind\n",
    "    binding_free_energy = BSS.FreeEnergy.Relative.difference(pmf_bound, pmf_free)\n",
    "    \n",
    "    return binding_free_energy, overlap_bound, overlap_free"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b3048cf",
   "metadata": {},
   "outputs": [],
   "source": [
    "def savePertSys(testset, ref_id, protein_id):\n",
    "    # Parameterise the reference ligand\n",
    "    if os.path.exists(\"./\" + ref_id):\n",
    "        print(\"Parameterised reference ligand exists\")\n",
    "        ref_ligand = BSS.IO.readMolecules([os.path.join(ref_id, ref_id) + '.prm7', os.path.join(ref_id, ref_id) + '.rst7'])[0]\n",
    "    else:\n",
    "        print(\"Parameterising the reference ligand ...\")\n",
    "        ref_ligand = BSS.Parameters.gaff2(BSS.IO.readMolecules(os.path.join('input', ref_id) + '.pdb')[0], work_dir = \"./reflig_par\").getMolecule()\n",
    "        BSS.IO.saveMolecules(os.path.join(ref_id, ref_id), ref_ligand, [\"PRM7\", \"RST7\"])\n",
    "\n",
    "    # Add missing hydrogens and parameterise the protein\n",
    "    if os.path.exists(\"./protein\"):\n",
    "        print(\"Parameterised protein exists\")\n",
    "        protein = BSS.IO.readMolecules(['./protein/protein.prm7', './protein/protein.rst7'])    \n",
    "    else:\n",
    "        print(\"Parameterising the protein ...\")\n",
    "        try:\n",
    "            protein = BSS.Parameters.ff14SB(BSS.IO.readMolecules(os.path.join('input', protein_id) + '.pdb')[0], work_dir = \"./protein_par_0\").getMolecule()\n",
    "        except:\n",
    "            protein = BSS.Parameters.ff14SB(BSS.IO.readMolecules(['./protein_par/leap.crd','./protein_par/leap.top'])[0], work_dir = \"./protein_par_1\").getMolecule()\n",
    "            BSS.IO.saveMolecules(\"./protein/protein\", protein, [\"PRM7\", \"RST7\"])\n",
    "    \n",
    "    getPertSys(testset, ref_ligand, protein)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "743ddce0",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Run FEPs and save results\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    '''\n",
    "    ref_id = 'CVD-0007756'\n",
    "    protein_id = '6LU7'\n",
    "    testset = pd.read_csv(\"./input/testset.csv\")[5:]\n",
    "    savePertSys(testset, ref_id, protein_id)\n",
    "    '''\n",
    "    \n",
    "    if not os.path.exists('output'): os.makedirs('output')\n",
    "    with open('./output/result.txt', 'w') as f:\n",
    "        f.writelines('Reference ligand ' + ref_id + '\\n')\n",
    "        \n",
    "    lam_bound = 12\n",
    "    lam_free = 10\n",
    "\n",
    "    for index, row in testset.iterrows():\n",
    "        title = row['Molecule Name']\n",
    "        FreeEnergy, overlap_bound, overlap_free = getFreeEnergy(title, lam_bound, lam_free)\n",
    "        getHeatMap(overlap_bound, overlap_free, title)\n",
    "        with open('./output/result.txt', 'a') as f:\n",
    "            f.writelines(title + ',' + str(FreeEnergy[0]) + ',' + str(FreeEnergy[1]) + '\\n')\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "857fcca0",
   "metadata": {},
   "outputs": [],
   "source": [
    "!jupyter nbconvert --to script BindingFE.ipynb"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
